<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Manipulating the DOM</title>
  <!-- Load Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Fira+Sans:900|Merriweather&display=swap" rel="stylesheet">  <!-- Load Styles -->
  <link href="css/styles.css" rel="stylesheet">
</head>
<body>
  <!-- HTML Follows BEM naming conventions 
  IDs are only used for sections to connect menu achors to sections -->
  <header class="page__header">
    <nav class="navbar__menu">
      <!-- Navigation starts as empty UL that will be populated with JS -->
      <ul id="navbar__list">
	  </ul>
    </nav>
  </header>
  <main>
    <header id='topOfPage' class="main__hero">
      <h1>Javascript bullets</h1>
    </header>
    <!-- Each Section has an ID (used for the anchor) and 
    a data attribute that will populate the li node.
    Adding more sections will automatically populate nav.
    The first section is set to active class by default -->
    <section id="section1" data-nav="Syntax" class="your-active-class">
      <div class="landing__container" >
        <h2>Syntax</h2>
        <p>There are now two new ways to declare variables in JavaScript: let and const.</p>

        <p>Variables declared with let and const eliminate this specific issue of hoisting because they’re scoped to the block, not to the function. Previously, when you used var, variables were either scoped globally or locally to an entire function scope. If a variable is declared using let or const inside a block of code (denoted by curly braces { }), then the variable is stuck in what is known as the temporal dead zone until the variable’s declaration is processed. This behavior prevents variables from being accessed only until after they’ve been declared.</p>
      </div>
    </section>
    <section id="section2" data-nav="DOM">
      <div class="landing__container">
        <h2>DOM</h2>
        <p>In this section, we'll look at the Document Object Model - otherwise known as the DOM.</p>

        <p>When you request a website, no matter what backend language is powering that website, it will respond with HTML. The browser receives a stream of HTML. The bytes are run through a complicated (but fully documented) parsing process that determines the different characters (e.g. the start tag character <, an attribute like href, a closing angle bracket like >). After parsing has occurred, a process called tokenization begins. Tokenization takes one character at a time and builds up tokens.</p>
      </div>
    </section>
    <section id="section3" data-nav="Events">
      <div class="landing__container">
        <h2>Events</h2>
        <p>Do you remember the Node Interface and the Element interface from the first lesson? Do you remember how the Element Interface is a descendant of the Node Interface, and therefore inherits all of Node's properties and methods?</p>

        <p>Remember that both the document object and any DOM element can be an event target. And again, why is this?...because both the Element Interface and the Document Interface inherit from the EventTarget Interface. So any individual element inherits from the Element Interface, which in turn inherits from the EventTarget Interface. Likewise, the document object comes from the Document Interface, which in turn inherits from the EventTarget Interface.</p>
      </div>
    </section>
	 <section id="section4" data-nav="Performance">
      <div class="landing__container">
        <h2>Performance</h2>
        <p>Reflow is the process of the browser laying out the page. It happens when you first display the DOM (generally after the DOM and CSS have been loaded), and happens again every time something could change the layout. This is a fairly expensive (slow) process. Repaint happens after reflow as the browser draws the new layout to the screen. This is fairly quick, but you still want to limit how often it happens.</p>

        <p>The simplest explanation of JavaScript's concurrency model uses two rules: If some JavaScript is running, let it run until it is finished ("run-to-completion"). If no JavaScript is running, run any pending event handlers. Since most JavaScript is run in response to an event, this is known as an event loop: Pick up the next event, run its handler, and repeat. There are three parts you have to think about around the event loop: the Call Stack, Web APIs/the browser, an Event Queue</p>
      </div>
    </section>
  </main>
  <div align="center">
  <a id="backToTopButton" href="#topOfPage" style="display:none">Back to top!</a>
  </div>
  <footer class="page__footer">
    <p>&copy Udacity</p>
  </footer>
<script src="js/app.js"></script>
</body>
</html>